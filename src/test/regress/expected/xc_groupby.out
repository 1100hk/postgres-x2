-- create required tables and fill them with data
create table tab1 (val int, val2 int);
create table tab2 (val int, val2 int);
insert into tab1 values (1, 1), (2, 1), (3, 1), (2, 2), (6, 2), (4, 3), (1, 3), (6, 3);
insert into tab2 values (1, 1), (4, 1), (8, 1), (2, 4), (9, 4), (3, 4), (4, 2), (5, 2), (3, 2);
select count(*), sum(val), avg(val), sum(val)::float8/count(*), val2 from tab1 group by val2;
 count | sum |        avg         |     ?column?     | val2 
-------+-----+--------------------+------------------+------
     3 |   6 | 2.0000000000000000 |                2 |    1
     2 |   8 | 4.0000000000000000 |                4 |    2
     3 |  11 | 3.6666666666666667 | 3.66666666666667 |    3
(3 rows)

-- joins and group by
select count(*), sum(tab1.val * tab2.val), avg(tab1.val*tab2.val), sum(tab1.val*tab2.val)::float8/count(*), tab1.val2, tab2.val2 from tab1 full outer join tab2 on tab1.val2 = tab2.val2 group by tab1.val2, tab2.val2;
 count | sum |         avg         |     ?column?     | val2 | val2 
-------+-----+---------------------+------------------+------+------
     6 |  96 | 16.0000000000000000 |               16 |    2 |    2
     9 |  78 |  8.6666666666666667 | 8.66666666666667 |    1 |    1
     3 |     |                     |                  |    3 |     
     3 |     |                     |                  |      |    4
(4 rows)

explain verbose select count(*), sum(tab1.val * tab2.val), avg(tab1.val*tab2.val), sum(tab1.val*tab2.val)::float8/count(*), tab1.val2, tab2.val2 from tab1 full outer join tab2 on tab1.val2 = tab2.val2 group by tab1.val2, tab2.val2;
                                                                                    QUERY PLAN                                                                                     
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 HashAggregate  (cost=2.09..2.13 rows=1 width=16)
   Output: count(*), sum((tab1.val * tab2.val)), avg((tab1.val * tab2.val)), ((sum((tab1.val * tab2.val)))::double precision / (count(*))::double precision), tab1.val2, tab2.val2
   ->  Merge Full Join  (cost=2.05..2.07 rows=1 width=16)
         Output: tab1.val, tab1.val2, tab2.val, tab2.val2
         Merge Cond: (tab1.val2 = tab2.val2)
         ->  Sort  (cost=1.02..1.03 rows=1 width=8)
               Output: tab1.val, tab1.val2
               Sort Key: tab1.val2
               ->  Materialize  (cost=0.00..1.01 rows=1 width=8)
                     Output: tab1.val, tab1.val2
                     ->  Data Node Scan (Node Count [2]) "SELECT val, val2 FROM public.tab1 tab1" on tab1  (cost=0.00..1.01 rows=1000 width=8)
                           Output: tab1.val, tab1.val2
         ->  Sort  (cost=1.02..1.03 rows=1 width=8)
               Output: tab2.val, tab2.val2
               Sort Key: tab2.val2
               ->  Materialize  (cost=0.00..1.01 rows=1 width=8)
                     Output: tab2.val, tab2.val2
                     ->  Data Node Scan (Node Count [2]) "SELECT val, val2 FROM public.tab2 tab2" on tab2  (cost=0.00..1.01 rows=1000 width=8)
                           Output: tab2.val, tab2.val2
(19 rows)

-- aggregates over aggregates
select sum(y) from (select sum(val) y, val2%2 x from tab1 group by val2) q1 group by x;
 sum 
-----
   8
  17
(2 rows)

explain verbose select sum(y) from (select sum(val) y, val2%2 x from tab1 group by val2) q1 group by x;
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 HashAggregate  (cost=1.05..1.06 rows=1 width=12)
   Output: sum((sum(tab1.val))), ((tab1.val2 % 2))
   ->  HashAggregate  (cost=1.02..1.03 rows=1 width=8)
         Output: sum(tab1.val), (tab1.val2 % 2), tab1.val2
         ->  Materialize  (cost=0.00..1.01 rows=1 width=8)
               Output: tab1.val, tab1.val2
               ->  Data Node Scan (Node Count [2])  (cost=0.00..1.01 rows=1000 width=8)
                     Output: tab1.val, tab1.val2
(8 rows)

-- group by without aggregate, just like distinct?
select val2 from tab1 group by val2;
 val2 
------
    1
    2
    3
(3 rows)

explain verbose select val2 from tab1 group by val2;
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 HashAggregate  (cost=1.02..1.03 rows=1 width=4)
   Output: tab1.val2
   ->  Materialize  (cost=0.00..0.00 rows=0 width=0)
         Output: tab1.val2
         ->  Data Node Scan (Node Count [2])  (cost=0.00..1.01 rows=1000 width=4)
               Output: tab1.val2
(6 rows)

-- group by with aggregates in expression
select count(*) + sum(val) + avg(val), val2 from tab1 group by val2;
      ?column?       | val2 
---------------------+------
 11.0000000000000000 |    1
 14.0000000000000000 |    2
 17.6666666666666667 |    3
(3 rows)

explain verbose select count(*) + sum(val) + avg(val), val2 from tab1 group by val2;
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 HashAggregate  (cost=1.02..1.05 rows=1 width=8)
   Output: (((count(*) + sum(val)))::numeric + avg(val)), val2
   ->  Materialize  (cost=0.00..1.01 rows=1 width=8)
         Output: val, val2
         ->  Data Node Scan (Node Count [2])  (cost=0.00..1.01 rows=1000 width=8)
               Output: val, val2
(6 rows)

-- group by with expressions in group by clause
select sum(val), avg(val), 2 * val2 from tab1 group by 2 * val2;
 sum |        avg         | ?column? 
-----+--------------------+----------
  11 | 3.6666666666666667 |        6
   6 | 2.0000000000000000 |        2
   8 | 4.0000000000000000 |        4
(3 rows)

explain verbose select sum(val), avg(val), 2 * val2 from tab1 group by 2 * val2;
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 HashAggregate  (cost=1.02..1.04 rows=1 width=8)
   Output: sum(val), avg(val), ((2 * val2))
   ->  Result  (cost=0.00..1.02 rows=1 width=8)
         Output: val, val2, (2 * val2)
         ->  Materialize  (cost=0.00..1.01 rows=1 width=8)
               Output: val, val2
               ->  Data Node Scan (Node Count [2])  (cost=0.00..1.01 rows=1000 width=8)
                     Output: val, val2
(8 rows)

drop table tab1;
drop table tab2;
-- repeat the same tests for replicated tables
-- create required tables and fill them with data
create table tab1 (val int, val2 int) distribute by replication;
create table tab2 (val int, val2 int) distribute by replication;
insert into tab1 values (1, 1), (2, 1), (3, 1), (2, 2), (6, 2), (4, 3), (1, 3), (6, 3);
insert into tab2 values (1, 1), (4, 1), (8, 1), (2, 4), (9, 4), (3, 4), (4, 2), (5, 2), (3, 2);
select count(*), sum(val), avg(val), sum(val)::float8/count(*), val2 from tab1 group by val2;
 count | sum |        avg         |     ?column?     | val2 
-------+-----+--------------------+------------------+------
     3 |   6 | 2.0000000000000000 |                2 |    1
     2 |   8 | 4.0000000000000000 |                4 |    2
     3 |  11 | 3.6666666666666667 | 3.66666666666667 |    3
(3 rows)

explain verbose select count(*), sum(val), avg(val), sum(val)::float8/count(*), val2 from tab1 group by val2;
                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 HashAggregate  (cost=1.03..1.06 rows=1 width=8)
   Output: count(*), sum(val), avg(val), ((sum(val))::double precision / (count(*))::double precision), val2
   ->  Materialize  (cost=0.00..1.01 rows=1 width=8)
         Output: val, val2
         ->  Data Node Scan (Node Count [1])  (cost=0.00..1.01 rows=1000 width=8)
               Output: val, val2
(6 rows)

-- joins and group by
select count(*), sum(tab1.val * tab2.val), avg(tab1.val*tab2.val), sum(tab1.val*tab2.val)::float8/count(*), tab1.val2, tab2.val2 from tab1 full outer join tab2 on tab1.val2 = tab2.val2 group by tab1.val2, tab2.val2;
 count | sum |         avg         |     ?column?     | val2 | val2 
-------+-----+---------------------+------------------+------+------
     6 |  96 | 16.0000000000000000 |               16 |    2 |    2
     9 |  78 |  8.6666666666666667 | 8.66666666666667 |    1 |    1
     3 |     |                     |                  |    3 |     
     3 |     |                     |                  |      |    4
(4 rows)

explain verbose select count(*), sum(tab1.val * tab2.val), avg(tab1.val*tab2.val), sum(tab1.val*tab2.val)::float8/count(*), tab1.val2, tab2.val2 from tab1 full outer join tab2 on tab1.val2 = tab2.val2 group by tab1.val2, tab2.val2;
                                                                                    QUERY PLAN                                                                                     
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 HashAggregate  (cost=2.09..2.13 rows=1 width=16)
   Output: count(*), sum((tab1.val * tab2.val)), avg((tab1.val * tab2.val)), ((sum((tab1.val * tab2.val)))::double precision / (count(*))::double precision), tab1.val2, tab2.val2
   ->  Merge Full Join  (cost=2.05..2.07 rows=1 width=16)
         Output: tab1.val, tab1.val2, tab2.val, tab2.val2
         Merge Cond: (tab1.val2 = tab2.val2)
         ->  Sort  (cost=1.02..1.03 rows=1 width=8)
               Output: tab1.val, tab1.val2
               Sort Key: tab1.val2
               ->  Materialize  (cost=0.00..1.01 rows=1 width=8)
                     Output: tab1.val, tab1.val2
                     ->  Data Node Scan (Node Count [1]) "SELECT val, val2 FROM public.tab1 tab1" on tab1  (cost=0.00..1.01 rows=1000 width=8)
                           Output: tab1.val, tab1.val2
         ->  Sort  (cost=1.02..1.03 rows=1 width=8)
               Output: tab2.val, tab2.val2
               Sort Key: tab2.val2
               ->  Materialize  (cost=0.00..1.01 rows=1 width=8)
                     Output: tab2.val, tab2.val2
                     ->  Data Node Scan (Node Count [1]) "SELECT val, val2 FROM public.tab2 tab2" on tab2  (cost=0.00..1.01 rows=1000 width=8)
                           Output: tab2.val, tab2.val2
(19 rows)

-- aggregates over aggregates
select sum(y) from (select sum(val) y, val2%2 x from tab1 group by val2) q1 group by x;
 sum 
-----
   8
  17
(2 rows)

explain verbose select sum(y) from (select sum(val) y, val2%2 x from tab1 group by val2) q1 group by x;
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 HashAggregate  (cost=1.05..1.06 rows=1 width=12)
   Output: sum((sum(tab1.val))), ((tab1.val2 % 2))
   ->  HashAggregate  (cost=1.02..1.03 rows=1 width=8)
         Output: sum(tab1.val), (tab1.val2 % 2), tab1.val2
         ->  Materialize  (cost=0.00..1.01 rows=1 width=8)
               Output: tab1.val, tab1.val2
               ->  Data Node Scan (Node Count [1])  (cost=0.00..1.01 rows=1000 width=8)
                     Output: tab1.val, tab1.val2
(8 rows)

-- group by without aggregate, just like distinct?
select val2 from tab1 group by val2;
 val2 
------
    1
    2
    3
(3 rows)

explain verbose select val2 from tab1 group by val2;
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 HashAggregate  (cost=1.02..1.03 rows=1 width=4)
   Output: tab1.val2
   ->  Materialize  (cost=0.00..0.00 rows=0 width=0)
         Output: tab1.val2
         ->  Data Node Scan (Node Count [1])  (cost=0.00..1.01 rows=1000 width=4)
               Output: tab1.val2
(6 rows)

-- group by with aggregates in expression
select count(*) + sum(val) + avg(val), val2 from tab1 group by val2;
      ?column?       | val2 
---------------------+------
 11.0000000000000000 |    1
 14.0000000000000000 |    2
 17.6666666666666667 |    3
(3 rows)

explain verbose select count(*) + sum(val) + avg(val), val2 from tab1 group by val2;
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 HashAggregate  (cost=1.02..1.05 rows=1 width=8)
   Output: (((count(*) + sum(val)))::numeric + avg(val)), val2
   ->  Materialize  (cost=0.00..1.01 rows=1 width=8)
         Output: val, val2
         ->  Data Node Scan (Node Count [1])  (cost=0.00..1.01 rows=1000 width=8)
               Output: val, val2
(6 rows)

-- group by with expressions in group by clause
select sum(val), avg(val), 2 * val2 from tab1 group by 2 * val2;
 sum |        avg         | ?column? 
-----+--------------------+----------
  11 | 3.6666666666666667 |        6
   6 | 2.0000000000000000 |        2
   8 | 4.0000000000000000 |        4
(3 rows)

explain verbose select sum(val), avg(val), 2 * val2 from tab1 group by 2 * val2;
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 HashAggregate  (cost=1.02..1.04 rows=1 width=8)
   Output: sum(val), avg(val), ((2 * val2))
   ->  Result  (cost=0.00..1.02 rows=1 width=8)
         Output: val, val2, (2 * val2)
         ->  Materialize  (cost=0.00..1.01 rows=1 width=8)
               Output: val, val2
               ->  Data Node Scan (Node Count [1])  (cost=0.00..1.01 rows=1000 width=8)
                     Output: val, val2
(8 rows)

drop table tab1;
drop table tab2;
-- some tests involving nulls, characters, float type etc.
create table def(a int, b varchar(25)); 
insert into def VALUES (NULL, NULL);
insert into def VALUES (1, NULL);
insert into def VALUES (NULL, 'One');
insert into def VALUES (2, 'Two');
insert into def VALUES (2, 'Two');
insert into def VALUES (3, 'Three');
insert into def VALUES (4, 'Three');
insert into def VALUES (5, 'Three');
insert into def VALUES (6, 'Two');
insert into def VALUES (7, NULL);
insert into def VALUES (8, 'Two');
insert into def VALUES (9, 'Three');
insert into def VALUES (10, 'Three');
select a,count(a) from def group by a order by a;
 a  | count 
----+-------
  1 |     1
  2 |     2
  3 |     1
  4 |     1
  5 |     1
  6 |     1
  7 |     1
  8 |     1
  9 |     1
 10 |     1
    |     0
(11 rows)

explain verbose select a,count(a) from def group by a order by a;
                                          QUERY PLAN                                          
----------------------------------------------------------------------------------------------
 GroupAggregate  (cost=1.02..1.05 rows=1 width=4)
   Output: a, count(a)
   ->  Sort  (cost=1.02..1.03 rows=1 width=4)
         Output: a
         Sort Key: def.a
         ->  Result  (cost=0.00..1.01 rows=1 width=4)
               Output: a
               ->  Materialize  (cost=0.00..1.01 rows=1 width=4)
                     Output: a, b
                     ->  Data Node Scan (Node Count [2])  (cost=0.00..1.01 rows=1000 width=4)
                           Output: a, b
(11 rows)

select avg(a) from def group by a; 
          avg           
------------------------
                       
     6.0000000000000000
     8.0000000000000000
     5.0000000000000000
     2.0000000000000000
 1.00000000000000000000
     9.0000000000000000
     3.0000000000000000
    10.0000000000000000
     7.0000000000000000
     4.0000000000000000
(11 rows)

select avg(a) from def group by a;
          avg           
------------------------
                       
     6.0000000000000000
     8.0000000000000000
     5.0000000000000000
 1.00000000000000000000
     9.0000000000000000
     2.0000000000000000
    10.0000000000000000
     7.0000000000000000
     3.0000000000000000
     4.0000000000000000
(11 rows)

explain verbose select avg(a) from def group by a;
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 HashAggregate  (cost=1.02..1.03 rows=1 width=4)
   Output: pg_catalog.avg((avg(def.a))), def.a
   ->  Materialize  (cost=0.00..0.00 rows=0 width=0)
         Output: (avg(def.a)), def.a
         ->  Data Node Scan (Node Count [2])  (cost=0.00..1.01 rows=1000 width=4)
               Output: avg(def.a), def.a
(6 rows)

select avg(a) from def group by b;
        avg         
--------------------
 4.0000000000000000
                   
 4.5000000000000000
 6.2000000000000000
(4 rows)

explain verbose select avg(a) from def group by b;
                                    QUERY PLAN                                     
-----------------------------------------------------------------------------------
 HashAggregate  (cost=1.02..1.03 rows=1 width=33)
   Output: pg_catalog.avg((avg(def.a))), def.b
   ->  Materialize  (cost=0.00..0.00 rows=0 width=0)
         Output: (avg(def.a)), def.b
         ->  Data Node Scan (Node Count [2])  (cost=0.00..1.01 rows=1000 width=33)
               Output: avg(def.a), def.b
(6 rows)

select sum(a) from def group by b;
 sum 
-----
   8
    
  18
  31
(4 rows)

explain verbose select sum(a) from def group by b;
                                    QUERY PLAN                                     
-----------------------------------------------------------------------------------
 HashAggregate  (cost=1.02..1.03 rows=1 width=33)
   Output: pg_catalog.sum((sum(def.a))), def.b
   ->  Materialize  (cost=0.00..0.00 rows=0 width=0)
         Output: (sum(def.a)), def.b
         ->  Data Node Scan (Node Count [2])  (cost=0.00..1.01 rows=1000 width=33)
               Output: sum(def.a), def.b
(6 rows)

select count(*) from def group by b;
 count 
-------
     3
     1
     4
     5
(4 rows)

explain verbose select count(*) from def group by b;
                                    QUERY PLAN                                     
-----------------------------------------------------------------------------------
 HashAggregate  (cost=1.02..1.03 rows=1 width=29)
   Output: pg_catalog.count(*), def.b
   ->  Materialize  (cost=0.00..0.00 rows=0 width=0)
         Output: (count(*)), def.b
         ->  Data Node Scan (Node Count [2])  (cost=0.00..1.01 rows=1000 width=29)
               Output: count(*), def.b
(6 rows)

select count(*) from def where a is not null group by a;
 count 
-------
     1
     1
     1
     1
     1
     1
     2
     1
     1
     1
(10 rows)

explain verbose select count(*) from def where a is not null group by a;
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 HashAggregate  (cost=1.02..1.03 rows=1 width=4)
   Output: pg_catalog.count(*), def.a
   ->  Materialize  (cost=0.00..0.00 rows=0 width=0)
         Output: (count(*)), def.a
         ->  Data Node Scan (Node Count [2])  (cost=0.00..1.01 rows=1000 width=4)
               Output: count(*), def.a
(6 rows)

select b from def group by b;
   b   
-------
 
 One
 Two
 Three
(4 rows)

explain verbose select b from def group by b;
                                    QUERY PLAN                                     
-----------------------------------------------------------------------------------
 HashAggregate  (cost=1.02..1.03 rows=1 width=29)
   Output: def.b
   ->  Materialize  (cost=0.00..0.00 rows=0 width=0)
         Output: def.b
         ->  Data Node Scan (Node Count [2])  (cost=0.00..1.01 rows=1000 width=29)
               Output: def.b
(6 rows)

select b,count(b) from def group by b;
   b   | count 
-------+-------
       |     0
 One   |     1
 Two   |     4
 Three |     5
(4 rows)

explain verbose select b,count(b) from def group by b;
                                    QUERY PLAN                                     
-----------------------------------------------------------------------------------
 HashAggregate  (cost=1.02..1.03 rows=1 width=29)
   Output: def.b, count((count(def.b)))
   ->  Materialize  (cost=0.00..0.00 rows=0 width=0)
         Output: def.b, (count(def.b))
         ->  Data Node Scan (Node Count [2])  (cost=0.00..1.01 rows=1000 width=29)
               Output: def.b, count(def.b)
(6 rows)

select count(*) from def where b is null group by b;
 count 
-------
     3
(1 row)

explain verbose select count(*) from def where b is null group by b;
                                    QUERY PLAN                                     
-----------------------------------------------------------------------------------
 HashAggregate  (cost=1.02..1.03 rows=1 width=29)
   Output: pg_catalog.count(*), def.b
   ->  Materialize  (cost=0.00..0.00 rows=0 width=0)
         Output: (count(*)), def.b
         ->  Data Node Scan (Node Count [2])  (cost=0.00..1.01 rows=1000 width=29)
               Output: count(*), def.b
(6 rows)

create table g(a int, b float, c numeric);
insert into g values(1,2.1,3.2);
insert into g values(1,2.1,3.2);
insert into g values(2,2.3,5.2);
select sum(a) from g group by a;
 sum 
-----
   2
   2
(2 rows)

explain verbose select sum(a) from g group by a;
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 HashAggregate  (cost=1.02..1.03 rows=1 width=4)
   Output: pg_catalog.sum((sum(g.a))), g.a
   ->  Materialize  (cost=0.00..0.00 rows=0 width=0)
         Output: (sum(g.a)), g.a
         ->  Data Node Scan (Node Count [2])  (cost=0.00..1.01 rows=1000 width=4)
               Output: sum(g.a), g.a
(6 rows)

select sum(b) from g group by b;
 sum 
-----
 2.3
 4.2
(2 rows)

explain verbose select sum(b) from g group by b;
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 HashAggregate  (cost=1.02..1.03 rows=1 width=8)
   Output: sum((sum(g.b))), g.b
   ->  Materialize  (cost=0.00..0.00 rows=0 width=0)
         Output: (sum(g.b)), g.b
         ->  Data Node Scan (Node Count [2])  (cost=0.00..1.01 rows=1000 width=8)
               Output: sum(g.b), g.b
(6 rows)

select sum(c) from g group by b;
 sum 
-----
 5.2
 6.4
(2 rows)

explain verbose select sum(c) from g group by b;
                                    QUERY PLAN                                     
-----------------------------------------------------------------------------------
 HashAggregate  (cost=1.02..1.03 rows=1 width=40)
   Output: sum((sum(g.c))), g.b
   ->  Materialize  (cost=0.00..0.00 rows=0 width=0)
         Output: (sum(g.c)), g.b
         ->  Data Node Scan (Node Count [2])  (cost=0.00..1.01 rows=1000 width=40)
               Output: sum(g.c), g.b
(6 rows)

select avg(a) from g group by b;
          avg           
------------------------
     2.0000000000000000
 1.00000000000000000000
(2 rows)

explain verbose select avg(a) from g group by b;
                                    QUERY PLAN                                     
-----------------------------------------------------------------------------------
 HashAggregate  (cost=1.02..1.03 rows=1 width=12)
   Output: pg_catalog.avg((avg(g.a))), g.b
   ->  Materialize  (cost=0.00..0.00 rows=0 width=0)
         Output: (avg(g.a)), g.b
         ->  Data Node Scan (Node Count [2])  (cost=0.00..1.01 rows=1000 width=12)
               Output: avg(g.a), g.b
(6 rows)

select avg(b) from g group by c;
 avg 
-----
 2.3
 2.1
(2 rows)

explain verbose select avg(b) from g group by c;
                                    QUERY PLAN                                     
-----------------------------------------------------------------------------------
 HashAggregate  (cost=1.02..1.03 rows=1 width=40)
   Output: pg_catalog.avg((avg(g.b))), g.c
   ->  Materialize  (cost=0.00..0.00 rows=0 width=0)
         Output: (avg(g.b)), g.c
         ->  Data Node Scan (Node Count [2])  (cost=0.00..1.01 rows=1000 width=40)
               Output: avg(g.b), g.c
(6 rows)

select avg(c) from g group by c;
        avg         
--------------------
 5.2000000000000000
 3.2000000000000000
(2 rows)

explain verbose select avg(c) from g group by c;
                                    QUERY PLAN                                     
-----------------------------------------------------------------------------------
 HashAggregate  (cost=1.02..1.03 rows=1 width=32)
   Output: pg_catalog.avg((avg(g.c))), g.c
   ->  Materialize  (cost=0.00..0.00 rows=0 width=0)
         Output: (avg(g.c)), g.c
         ->  Data Node Scan (Node Count [2])  (cost=0.00..1.01 rows=1000 width=32)
               Output: avg(g.c), g.c
(6 rows)

drop table def;
drop table g;
-- same test with replicated tables
create table def(a int, b varchar(25)) distribute by replication; 
insert into def VALUES (NULL, NULL);
insert into def VALUES (1, NULL);
insert into def VALUES (NULL, 'One');
insert into def VALUES (2, 'Two');
insert into def VALUES (2, 'Two');
insert into def VALUES (3, 'Three');
insert into def VALUES (4, 'Three');
insert into def VALUES (5, 'Three');
insert into def VALUES (6, 'Two');
insert into def VALUES (7, NULL);
insert into def VALUES (8, 'Two');
insert into def VALUES (9, 'Three');
insert into def VALUES (10, 'Three');
select a,count(a) from def group by a order by a;
 a  | count 
----+-------
  1 |     1
  2 |     2
  3 |     1
  4 |     1
  5 |     1
  6 |     1
  7 |     1
  8 |     1
  9 |     1
 10 |     1
    |     0
(11 rows)

explain verbose select a,count(a) from def group by a order by a;
                                          QUERY PLAN                                          
----------------------------------------------------------------------------------------------
 GroupAggregate  (cost=1.02..1.05 rows=1 width=4)
   Output: a, count(a)
   ->  Sort  (cost=1.02..1.03 rows=1 width=4)
         Output: a
         Sort Key: def.a
         ->  Result  (cost=0.00..1.01 rows=1 width=4)
               Output: a
               ->  Materialize  (cost=0.00..1.01 rows=1 width=4)
                     Output: a, b
                     ->  Data Node Scan (Node Count [1])  (cost=0.00..1.01 rows=1000 width=4)
                           Output: a, b
(11 rows)

select avg(a) from def group by a; 
          avg           
------------------------
                       
     6.0000000000000000
     8.0000000000000000
     5.0000000000000000
 1.00000000000000000000
     9.0000000000000000
     2.0000000000000000
     3.0000000000000000
    10.0000000000000000
     7.0000000000000000
     4.0000000000000000
(11 rows)

explain verbose select avg(a) from def group by a; 
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 HashAggregate  (cost=1.02..1.03 rows=1 width=4)
   Output: pg_catalog.avg((avg(def.a))), def.a
   ->  Materialize  (cost=0.00..0.00 rows=0 width=0)
         Output: (avg(def.a)), def.a
         ->  Data Node Scan (Node Count [1])  (cost=0.00..1.01 rows=1000 width=4)
               Output: avg(def.a), def.a
(6 rows)

select avg(a) from def group by a;
          avg           
------------------------
                       
     6.0000000000000000
     8.0000000000000000
     5.0000000000000000
 1.00000000000000000000
     9.0000000000000000
     2.0000000000000000
     3.0000000000000000
    10.0000000000000000
     7.0000000000000000
     4.0000000000000000
(11 rows)

explain verbose select avg(a) from def group by a;
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 HashAggregate  (cost=1.02..1.03 rows=1 width=4)
   Output: pg_catalog.avg((avg(def.a))), def.a
   ->  Materialize  (cost=0.00..0.00 rows=0 width=0)
         Output: (avg(def.a)), def.a
         ->  Data Node Scan (Node Count [1])  (cost=0.00..1.01 rows=1000 width=4)
               Output: avg(def.a), def.a
(6 rows)

select avg(a) from def group by b;
        avg         
--------------------
 4.0000000000000000
                   
 4.5000000000000000
 6.2000000000000000
(4 rows)

explain verbose select avg(a) from def group by b;
                                    QUERY PLAN                                     
-----------------------------------------------------------------------------------
 HashAggregate  (cost=1.02..1.03 rows=1 width=33)
   Output: pg_catalog.avg((avg(def.a))), def.b
   ->  Materialize  (cost=0.00..0.00 rows=0 width=0)
         Output: (avg(def.a)), def.b
         ->  Data Node Scan (Node Count [1])  (cost=0.00..1.01 rows=1000 width=33)
               Output: avg(def.a), def.b
(6 rows)

select sum(a) from def group by b;
 sum 
-----
   8
    
  18
  31
(4 rows)

explain verbose select sum(a) from def group by b;
                                    QUERY PLAN                                     
-----------------------------------------------------------------------------------
 HashAggregate  (cost=1.02..1.03 rows=1 width=33)
   Output: pg_catalog.sum((sum(def.a))), def.b
   ->  Materialize  (cost=0.00..0.00 rows=0 width=0)
         Output: (sum(def.a)), def.b
         ->  Data Node Scan (Node Count [1])  (cost=0.00..1.01 rows=1000 width=33)
               Output: sum(def.a), def.b
(6 rows)

select count(*) from def group by b;
 count 
-------
     3
     1
     4
     5
(4 rows)

explain verbose select count(*) from def group by b;
                                    QUERY PLAN                                     
-----------------------------------------------------------------------------------
 HashAggregate  (cost=1.02..1.03 rows=1 width=29)
   Output: pg_catalog.count(*), def.b
   ->  Materialize  (cost=0.00..0.00 rows=0 width=0)
         Output: (count(*)), def.b
         ->  Data Node Scan (Node Count [1])  (cost=0.00..1.01 rows=1000 width=29)
               Output: count(*), def.b
(6 rows)

select count(*) from def where a is not null group by a;
 count 
-------
     1
     1
     1
     1
     1
     1
     2
     1
     1
     1
(10 rows)

explain verbose select count(*) from def where a is not null group by a;
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 HashAggregate  (cost=1.02..1.03 rows=1 width=4)
   Output: pg_catalog.count(*), def.a
   ->  Materialize  (cost=0.00..0.00 rows=0 width=0)
         Output: (count(*)), def.a
         ->  Data Node Scan (Node Count [1])  (cost=0.00..1.01 rows=1000 width=4)
               Output: count(*), def.a
(6 rows)

select b from def group by b;
   b   
-------
 
 One
 Two
 Three
(4 rows)

explain verbose select b from def group by b;
                                    QUERY PLAN                                     
-----------------------------------------------------------------------------------
 HashAggregate  (cost=1.02..1.03 rows=1 width=29)
   Output: def.b
   ->  Materialize  (cost=0.00..0.00 rows=0 width=0)
         Output: def.b
         ->  Data Node Scan (Node Count [1])  (cost=0.00..1.01 rows=1000 width=29)
               Output: def.b
(6 rows)

select b,count(b) from def group by b;
   b   | count 
-------+-------
       |     0
 One   |     1
 Two   |     4
 Three |     5
(4 rows)

explain verbose select b,count(b) from def group by b;
                                    QUERY PLAN                                     
-----------------------------------------------------------------------------------
 HashAggregate  (cost=1.02..1.03 rows=1 width=29)
   Output: def.b, count((count(def.b)))
   ->  Materialize  (cost=0.00..0.00 rows=0 width=0)
         Output: def.b, (count(def.b))
         ->  Data Node Scan (Node Count [1])  (cost=0.00..1.01 rows=1000 width=29)
               Output: def.b, count(def.b)
(6 rows)

select count(*) from def where b is null group by b;
 count 
-------
     3
(1 row)

explain verbose select count(*) from def where b is null group by b;
                                    QUERY PLAN                                     
-----------------------------------------------------------------------------------
 HashAggregate  (cost=1.02..1.03 rows=1 width=29)
   Output: pg_catalog.count(*), def.b
   ->  Materialize  (cost=0.00..0.00 rows=0 width=0)
         Output: (count(*)), def.b
         ->  Data Node Scan (Node Count [1])  (cost=0.00..1.01 rows=1000 width=29)
               Output: count(*), def.b
(6 rows)

create table g(a int, b float, c numeric) distribute by replication;
insert into g values(1,2.1,3.2);
insert into g values(1,2.1,3.2);
insert into g values(2,2.3,5.2);
select sum(a) from g group by a;
 sum 
-----
   2
   2
(2 rows)

explain verbose select sum(a) from g group by a;
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 HashAggregate  (cost=1.02..1.03 rows=1 width=4)
   Output: pg_catalog.sum((sum(g.a))), g.a
   ->  Materialize  (cost=0.00..0.00 rows=0 width=0)
         Output: (sum(g.a)), g.a
         ->  Data Node Scan (Node Count [1])  (cost=0.00..1.01 rows=1000 width=4)
               Output: sum(g.a), g.a
(6 rows)

select sum(b) from g group by b;
 sum 
-----
 2.3
 4.2
(2 rows)

explain verbose select sum(b) from g group by b;
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 HashAggregate  (cost=1.02..1.03 rows=1 width=8)
   Output: sum((sum(g.b))), g.b
   ->  Materialize  (cost=0.00..0.00 rows=0 width=0)
         Output: (sum(g.b)), g.b
         ->  Data Node Scan (Node Count [1])  (cost=0.00..1.01 rows=1000 width=8)
               Output: sum(g.b), g.b
(6 rows)

select sum(c) from g group by b;
 sum 
-----
 5.2
 6.4
(2 rows)

explain verbose select sum(c) from g group by b;
                                    QUERY PLAN                                     
-----------------------------------------------------------------------------------
 HashAggregate  (cost=1.02..1.03 rows=1 width=40)
   Output: sum((sum(g.c))), g.b
   ->  Materialize  (cost=0.00..0.00 rows=0 width=0)
         Output: (sum(g.c)), g.b
         ->  Data Node Scan (Node Count [1])  (cost=0.00..1.01 rows=1000 width=40)
               Output: sum(g.c), g.b
(6 rows)

select avg(a) from g group by b;
          avg           
------------------------
     2.0000000000000000
 1.00000000000000000000
(2 rows)

explain verbose select avg(a) from g group by b;
                                    QUERY PLAN                                     
-----------------------------------------------------------------------------------
 HashAggregate  (cost=1.02..1.03 rows=1 width=12)
   Output: pg_catalog.avg((avg(g.a))), g.b
   ->  Materialize  (cost=0.00..0.00 rows=0 width=0)
         Output: (avg(g.a)), g.b
         ->  Data Node Scan (Node Count [1])  (cost=0.00..1.01 rows=1000 width=12)
               Output: avg(g.a), g.b
(6 rows)

select avg(b) from g group by c;
 avg 
-----
 2.3
 2.1
(2 rows)

explain verbose select avg(b) from g group by c;
                                    QUERY PLAN                                     
-----------------------------------------------------------------------------------
 HashAggregate  (cost=1.02..1.03 rows=1 width=40)
   Output: pg_catalog.avg((avg(g.b))), g.c
   ->  Materialize  (cost=0.00..0.00 rows=0 width=0)
         Output: (avg(g.b)), g.c
         ->  Data Node Scan (Node Count [1])  (cost=0.00..1.01 rows=1000 width=40)
               Output: avg(g.b), g.c
(6 rows)

select avg(c) from g group by c;
        avg         
--------------------
 5.2000000000000000
 3.2000000000000000
(2 rows)

explain verbose select avg(c) from g group by c;
                                    QUERY PLAN                                     
-----------------------------------------------------------------------------------
 HashAggregate  (cost=1.02..1.03 rows=1 width=32)
   Output: pg_catalog.avg((avg(g.c))), g.c
   ->  Materialize  (cost=0.00..0.00 rows=0 width=0)
         Output: (avg(g.c)), g.c
         ->  Data Node Scan (Node Count [1])  (cost=0.00..1.01 rows=1000 width=32)
               Output: avg(g.c), g.c
(6 rows)

drop table def;
drop table g;
