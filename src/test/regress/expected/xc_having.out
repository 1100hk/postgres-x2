-- this file contains tests for HAVING clause with combinations of following
-- 1. enable_hashagg = on/off (to force the grouping by sorting)
-- 2. distributed or replicated tables across the datanodes
-- If a testcase is added to any of the combinations, please check if it's
-- applicable in other combinations as well.
-- Combination 1: enable_hashagg on and distributed tables
set enable_hashagg to on;
-- create required tables and fill them with data
create table tab1 (val int, val2 int);
create table tab2 (val int, val2 int);
insert into tab1 values (1, 1), (2, 1), (3, 1), (2, 2), (6, 2), (4, 3), (1, 3), (6, 3);
insert into tab2 values (1, 1), (4, 1), (8, 1), (2, 4), (9, 4), (3, 4), (4, 2), (5, 2), (3, 2);
-- having clause not containing any aggregate
select count(*), sum(val), avg(val), sum(val)::float8/count(*), val2 from tab1 group by val2 having val2 + 1 > 3;
 count | sum |        avg         |     ?column?     | val2 
-------+-----+--------------------+------------------+------
     3 |  11 | 3.6666666666666667 | 3.66666666666667 |    3
(1 row)

explain verbose select count(*), sum(val), avg(val), sum(val)::float8/count(*), val2 from tab1 group by val2 having val2 + 1 > 3;
                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 HashAggregate  (cost=1.03..1.06 rows=1 width=8)
   Output: count(*), sum(val), avg(val), ((sum(val))::double precision / (count(*))::double precision), val2
   ->  Materialize  (cost=0.00..1.02 rows=1 width=8)
         Output: val, val2
         ->  Data Node Scan (Node Count [2])  (cost=0.00..1.01 rows=1000 width=8)
               Output: val, val2
(6 rows)

-- having clause containing aggregate
select count(*), sum(val), avg(val), sum(val)::float8/count(*), val2 from tab1 group by val2 having avg(val) > 3.75;
 count | sum |        avg         | ?column? | val2 
-------+-----+--------------------+----------+------
     2 |   8 | 4.0000000000000000 |        4 |    2
(1 row)

explain verbose select count(*), sum(val), avg(val), sum(val)::float8/count(*), val2 from tab1 group by val2 having avg(val) > 3.75;
                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 HashAggregate  (cost=1.03..1.07 rows=1 width=8)
   Output: count(*), sum(val), avg(val), ((sum(val))::double precision / (count(*))::double precision), val2
   Filter: (avg(tab1.val) > 3.75)
   ->  Materialize  (cost=0.00..1.01 rows=1 width=8)
         Output: val, val2
         ->  Data Node Scan (Node Count [2])  (cost=0.00..1.01 rows=1000 width=8)
               Output: val, val2
(7 rows)

select count(*), sum(val), avg(val), sum(val)::float8/count(*), val2 from tab1 group by val2 having avg(val) > 3.75 or val2 > 2;
 count | sum |        avg         |     ?column?     | val2 
-------+-----+--------------------+------------------+------
     2 |   8 | 4.0000000000000000 |                4 |    2
     3 |  11 | 3.6666666666666667 | 3.66666666666667 |    3
(2 rows)

explain verbose select count(*), sum(val), avg(val), sum(val)::float8/count(*), val2 from tab1 group by val2 having avg(val) > 3.75 or val2 > 2;
                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 HashAggregate  (cost=1.03..1.07 rows=1 width=8)
   Output: count(*), sum(val), avg(val), ((sum(val))::double precision / (count(*))::double precision), val2
   Filter: ((avg(tab1.val) > 3.75) OR (tab1.val2 > 2))
   ->  Materialize  (cost=0.00..1.01 rows=1 width=8)
         Output: val, val2
         ->  Data Node Scan (Node Count [2])  (cost=0.00..1.01 rows=1000 width=8)
               Output: val, val2
(7 rows)

select count(*), sum(val), avg(val), sum(val)::float8/count(*), val2 from tab1 group by val2 having avg(val) > 3.75 and val2 > 2;
 count | sum | avg | ?column? | val2 
-------+-----+-----+----------+------
(0 rows)

explain verbose select count(*), sum(val), avg(val), sum(val)::float8/count(*), val2 from tab1 group by val2 having avg(val) > 3.75 and val2 > 2;
                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 HashAggregate  (cost=1.03..1.07 rows=1 width=8)
   Output: count(*), sum(val), avg(val), ((sum(val))::double precision / (count(*))::double precision), val2
   Filter: (avg(tab1.val) > 3.75)
   ->  Materialize  (cost=0.00..1.02 rows=1 width=8)
         Output: val, val2
         ->  Data Node Scan (Node Count [2])  (cost=0.00..1.01 rows=1000 width=8)
               Output: val, val2
(7 rows)

-- joins and group by and having
select count(*), sum(tab1.val * tab2.val), avg(tab1.val*tab2.val), sum(tab1.val*tab2.val)::float8/count(*), tab1.val2, tab2.val2 from tab1 full outer join tab2 on tab1.val2 = tab2.val2 group by tab1.val2, tab2.val2 having tab1.val2 + tab2.val2 > 2;
 count | sum |         avg         | ?column? | val2 | val2 
-------+-----+---------------------+----------+------+------
     6 |  96 | 16.0000000000000000 |       16 |    2 |    2
(1 row)

explain verbose select count(*), sum(tab1.val * tab2.val), avg(tab1.val*tab2.val), sum(tab1.val*tab2.val)::float8/count(*), tab1.val2, tab2.val2 from tab1 full outer join tab2 on tab1.val2 = tab2.val2 group by tab1.val2, tab2.val2 having tab1.val2 + tab2.val2 > 2;
                                                                                    QUERY PLAN                                                                                     
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 HashAggregate  (cost=2.06..2.10 rows=1 width=16)
   Output: count(*), sum((tab1.val * tab2.val)), avg((tab1.val * tab2.val)), ((sum((tab1.val * tab2.val)))::double precision / (count(*))::double precision), tab1.val2, tab2.val2
   ->  Nested Loop  (cost=0.00..2.05 rows=1 width=16)
         Output: tab1.val, tab1.val2, tab2.val, tab2.val2
         Join Filter: ((tab1.val2 = tab2.val2) AND ((tab1.val2 + tab2.val2) > 2))
         ->  Materialize  (cost=0.00..1.01 rows=1 width=8)
               Output: tab1.val, tab1.val2
               ->  Data Node Scan (Node Count [2]) on tab1  (cost=0.00..1.01 rows=1000 width=8)
                     Output: tab1.val, tab1.val2
         ->  Materialize  (cost=0.00..1.01 rows=1 width=8)
               Output: tab2.val, tab2.val2
               ->  Data Node Scan (Node Count [2]) on tab2  (cost=0.00..1.01 rows=1000 width=8)
                     Output: tab2.val, tab2.val2
(13 rows)

-- group by and having, without aggregate in the target list
select val2 from tab1 group by val2 having sum(val) > 8;
 val2 
------
    3
(1 row)

explain verbose select val2 from tab1 group by val2 having sum(val) > 8;
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 HashAggregate  (cost=1.02..1.03 rows=1 width=8)
   Output: val2
   Filter: (sum(tab1.val) > 8)
   ->  Materialize  (cost=0.00..1.01 rows=1 width=8)
         Output: val, val2
         ->  Data Node Scan (Node Count [2])  (cost=0.00..1.01 rows=1000 width=8)
               Output: val, val2
(7 rows)

select val + val2 from tab1 group by val + val2 having sum(val) > 5;
 ?column? 
----------
        4
        8
        9
(3 rows)

explain verbose select val + val2 from tab1 group by val + val2 having sum(val) > 5;
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 HashAggregate  (cost=1.02..1.04 rows=1 width=8)
   Output: ((val + val2))
   Filter: (sum(tab1.val) > 5)
   ->  Result  (cost=0.00..1.02 rows=1 width=8)
         Output: val, val2, (val + val2)
         ->  Materialize  (cost=0.00..1.01 rows=1 width=8)
               Output: val, val2
               ->  Data Node Scan (Node Count [2])  (cost=0.00..1.01 rows=1000 width=8)
                     Output: val, val2
(9 rows)

-- group by with aggregates in expression
select count(*) + sum(val) + avg(val), val2 from tab1 group by val2 having min(val) < val2;
      ?column?       | val2 
---------------------+------
 17.6666666666666667 |    3
(1 row)

explain verbose select count(*) + sum(val) + avg(val), val2 from tab1 group by val2 having min(val) < val2;
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 HashAggregate  (cost=1.03..1.06 rows=1 width=8)
   Output: (((count(*) + sum(val)))::numeric + avg(val)), val2
   Filter: (min(tab1.val) < tab1.val2)
   ->  Materialize  (cost=0.00..1.01 rows=1 width=8)
         Output: val, val2
         ->  Data Node Scan (Node Count [2])  (cost=0.00..1.01 rows=1000 width=8)
               Output: val, val2
(7 rows)

drop table tab1;
drop table tab2;
-- Combination 2, enable_hashagg on and replicated tables.
-- repeat the same tests for replicated tables
-- create required tables and fill them with data
create table tab1 (val int, val2 int) distribute by replication;
create table tab2 (val int, val2 int) distribute by replication;
insert into tab1 values (1, 1), (2, 1), (3, 1), (2, 2), (6, 2), (4, 3), (1, 3), (6, 3);
insert into tab2 values (1, 1), (4, 1), (8, 1), (2, 4), (9, 4), (3, 4), (4, 2), (5, 2), (3, 2);
-- having clause not containing any aggregate
select count(*), sum(val), avg(val), sum(val)::float8/count(*), val2 from tab1 group by val2 having val2 + 1 > 3;
 count | sum |        avg         |     ?column?     | val2 
-------+-----+--------------------+------------------+------
     3 |  11 | 3.6666666666666667 | 3.66666666666667 |    3
(1 row)

explain verbose select count(*), sum(val), avg(val), sum(val)::float8/count(*), val2 from tab1 group by val2 having val2 + 1 > 3;
                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 HashAggregate  (cost=1.03..1.06 rows=1 width=8)
   Output: count(*), sum(val), avg(val), ((sum(val))::double precision / (count(*))::double precision), val2
   ->  Materialize  (cost=0.00..1.02 rows=1 width=8)
         Output: val, val2
         ->  Data Node Scan (Node Count [1])  (cost=0.00..1.01 rows=1000 width=8)
               Output: val, val2
(6 rows)

-- having clause containing aggregate
select count(*), sum(val), avg(val), sum(val)::float8/count(*), val2 from tab1 group by val2 having avg(val) > 3.75;
 count | sum |        avg         | ?column? | val2 
-------+-----+--------------------+----------+------
     2 |   8 | 4.0000000000000000 |        4 |    2
(1 row)

explain verbose select count(*), sum(val), avg(val), sum(val)::float8/count(*), val2 from tab1 group by val2 having avg(val) > 3.75;
                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 HashAggregate  (cost=1.03..1.07 rows=1 width=8)
   Output: count(*), sum(val), avg(val), ((sum(val))::double precision / (count(*))::double precision), val2
   Filter: (avg(tab1.val) > 3.75)
   ->  Materialize  (cost=0.00..1.01 rows=1 width=8)
         Output: val, val2
         ->  Data Node Scan (Node Count [1])  (cost=0.00..1.01 rows=1000 width=8)
               Output: val, val2
(7 rows)

select count(*), sum(val), avg(val), sum(val)::float8/count(*), val2 from tab1 group by val2 having avg(val) > 3.75 or val2 > 2;
 count | sum |        avg         |     ?column?     | val2 
-------+-----+--------------------+------------------+------
     2 |   8 | 4.0000000000000000 |                4 |    2
     3 |  11 | 3.6666666666666667 | 3.66666666666667 |    3
(2 rows)

explain verbose select count(*), sum(val), avg(val), sum(val)::float8/count(*), val2 from tab1 group by val2 having avg(val) > 3.75 or val2 > 2;
                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 HashAggregate  (cost=1.03..1.07 rows=1 width=8)
   Output: count(*), sum(val), avg(val), ((sum(val))::double precision / (count(*))::double precision), val2
   Filter: ((avg(tab1.val) > 3.75) OR (tab1.val2 > 2))
   ->  Materialize  (cost=0.00..1.01 rows=1 width=8)
         Output: val, val2
         ->  Data Node Scan (Node Count [1])  (cost=0.00..1.01 rows=1000 width=8)
               Output: val, val2
(7 rows)

select count(*), sum(val), avg(val), sum(val)::float8/count(*), val2 from tab1 group by val2 having avg(val) > 3.75 and val2 > 2;
 count | sum | avg | ?column? | val2 
-------+-----+-----+----------+------
(0 rows)

explain verbose select count(*), sum(val), avg(val), sum(val)::float8/count(*), val2 from tab1 group by val2 having avg(val) > 3.75 and val2 > 2;
                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 HashAggregate  (cost=1.03..1.07 rows=1 width=8)
   Output: count(*), sum(val), avg(val), ((sum(val))::double precision / (count(*))::double precision), val2
   Filter: (avg(tab1.val) > 3.75)
   ->  Materialize  (cost=0.00..1.02 rows=1 width=8)
         Output: val, val2
         ->  Data Node Scan (Node Count [1])  (cost=0.00..1.01 rows=1000 width=8)
               Output: val, val2
(7 rows)

-- joins and group by and having
select count(*), sum(tab1.val * tab2.val), avg(tab1.val*tab2.val), sum(tab1.val*tab2.val)::float8/count(*), tab1.val2, tab2.val2 from tab1 full outer join tab2 on tab1.val2 = tab2.val2 group by tab1.val2, tab2.val2 having tab1.val2 + tab2.val2 > 2;
 count | sum |         avg         | ?column? | val2 | val2 
-------+-----+---------------------+----------+------+------
     6 |  96 | 16.0000000000000000 |       16 |    2 |    2
(1 row)

explain verbose select count(*), sum(tab1.val * tab2.val), avg(tab1.val*tab2.val), sum(tab1.val*tab2.val)::float8/count(*), tab1.val2, tab2.val2 from tab1 full outer join tab2 on tab1.val2 = tab2.val2 group by tab1.val2, tab2.val2 having tab1.val2 + tab2.val2 > 2;
                                                                                    QUERY PLAN                                                                                     
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 HashAggregate  (cost=2.06..2.10 rows=1 width=16)
   Output: count(*), sum((tab1.val * tab2.val)), avg((tab1.val * tab2.val)), ((sum((tab1.val * tab2.val)))::double precision / (count(*))::double precision), tab1.val2, tab2.val2
   ->  Nested Loop  (cost=0.00..2.05 rows=1 width=16)
         Output: tab1.val, tab1.val2, tab2.val, tab2.val2
         Join Filter: ((tab1.val2 = tab2.val2) AND ((tab1.val2 + tab2.val2) > 2))
         ->  Materialize  (cost=0.00..1.01 rows=1 width=8)
               Output: tab1.val, tab1.val2
               ->  Data Node Scan (Node Count [1]) on tab1  (cost=0.00..1.01 rows=1000 width=8)
                     Output: tab1.val, tab1.val2
         ->  Materialize  (cost=0.00..1.01 rows=1 width=8)
               Output: tab2.val, tab2.val2
               ->  Data Node Scan (Node Count [1]) on tab2  (cost=0.00..1.01 rows=1000 width=8)
                     Output: tab2.val, tab2.val2
(13 rows)

-- group by and having, without aggregate in the target list
select val2 from tab1 group by val2 having sum(val) > 8;
 val2 
------
    3
(1 row)

explain verbose select val2 from tab1 group by val2 having sum(val) > 8;
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 HashAggregate  (cost=1.02..1.03 rows=1 width=8)
   Output: val2
   Filter: (sum(tab1.val) > 8)
   ->  Materialize  (cost=0.00..1.01 rows=1 width=8)
         Output: val, val2
         ->  Data Node Scan (Node Count [1])  (cost=0.00..1.01 rows=1000 width=8)
               Output: val, val2
(7 rows)

select val + val2 from tab1 group by val + val2 having sum(val) > 5;
 ?column? 
----------
        4
        8
        9
(3 rows)

explain verbose select val + val2 from tab1 group by val + val2 having sum(val) > 5;
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 HashAggregate  (cost=1.02..1.04 rows=1 width=8)
   Output: ((val + val2))
   Filter: (sum(tab1.val) > 5)
   ->  Result  (cost=0.00..1.02 rows=1 width=8)
         Output: val, val2, (val + val2)
         ->  Materialize  (cost=0.00..1.01 rows=1 width=8)
               Output: val, val2
               ->  Data Node Scan (Node Count [1])  (cost=0.00..1.01 rows=1000 width=8)
                     Output: val, val2
(9 rows)

-- group by with aggregates in expression
select count(*) + sum(val) + avg(val), val2 from tab1 group by val2 having min(val) < val2;
      ?column?       | val2 
---------------------+------
 17.6666666666666667 |    3
(1 row)

explain verbose select count(*) + sum(val) + avg(val), val2 from tab1 group by val2 having min(val) < val2;
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 HashAggregate  (cost=1.03..1.06 rows=1 width=8)
   Output: (((count(*) + sum(val)))::numeric + avg(val)), val2
   Filter: (min(tab1.val) < tab1.val2)
   ->  Materialize  (cost=0.00..1.01 rows=1 width=8)
         Output: val, val2
         ->  Data Node Scan (Node Count [1])  (cost=0.00..1.01 rows=1000 width=8)
               Output: val, val2
(7 rows)

drop table tab1;
drop table tab2;
-- Combination 3 enable_hashagg off and distributed tables
set enable_hashagg to off;
-- create required tables and fill them with data
create table tab1 (val int, val2 int);
create table tab2 (val int, val2 int);
insert into tab1 values (1, 1), (2, 1), (3, 1), (2, 2), (6, 2), (4, 3), (1, 3), (6, 3);
insert into tab2 values (1, 1), (4, 1), (8, 1), (2, 4), (9, 4), (3, 4), (4, 2), (5, 2), (3, 2);
-- having clause not containing any aggregate
select count(*), sum(val), avg(val), sum(val)::float8/count(*), val2 from tab1 group by val2 having val2 + 1 > 3;
 count | sum |        avg         |     ?column?     | val2 
-------+-----+--------------------+------------------+------
     3 |  11 | 3.6666666666666667 | 3.66666666666667 |    3
(1 row)

explain verbose select count(*), sum(val), avg(val), sum(val)::float8/count(*), val2 from tab1 group by val2 having val2 + 1 > 3;
                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=1.03..1.08 rows=1 width=8)
   Output: count(*), sum(val), avg(val), ((sum(val))::double precision / (count(*))::double precision), val2
   ->  Sort  (cost=1.03..1.03 rows=1 width=8)
         Output: val, val2
         Sort Key: tab1.val2
         ->  Result  (cost=0.00..1.02 rows=1 width=8)
               Output: val, val2
               ->  Materialize  (cost=0.00..1.02 rows=1 width=8)
                     Output: val, val2
                     ->  Data Node Scan (Node Count [2])  (cost=0.00..1.01 rows=1000 width=8)
                           Output: val, val2
(11 rows)

-- having clause containing aggregate
select count(*), sum(val), avg(val), sum(val)::float8/count(*), val2 from tab1 group by val2 having avg(val) > 3.75;
 count | sum |        avg         | ?column? | val2 
-------+-----+--------------------+----------+------
     2 |   8 | 4.0000000000000000 |        4 |    2
(1 row)

explain verbose select count(*), sum(val), avg(val), sum(val)::float8/count(*), val2 from tab1 group by val2 having avg(val) > 3.75;
                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=1.02..1.08 rows=1 width=8)
   Output: count(*), sum(val), avg(val), ((sum(val))::double precision / (count(*))::double precision), val2
   Filter: (avg(tab1.val) > 3.75)
   ->  Sort  (cost=1.02..1.03 rows=1 width=8)
         Output: val, val2
         Sort Key: tab1.val2
         ->  Result  (cost=0.00..1.01 rows=1 width=8)
               Output: val, val2
               ->  Materialize  (cost=0.00..1.01 rows=1 width=8)
                     Output: val, val2
                     ->  Data Node Scan (Node Count [2])  (cost=0.00..1.01 rows=1000 width=8)
                           Output: val, val2
(12 rows)

select count(*), sum(val), avg(val), sum(val)::float8/count(*), val2 from tab1 group by val2 having avg(val) > 3.75 or val2 > 2;
 count | sum |        avg         |     ?column?     | val2 
-------+-----+--------------------+------------------+------
     2 |   8 | 4.0000000000000000 |                4 |    2
     3 |  11 | 3.6666666666666667 | 3.66666666666667 |    3
(2 rows)

explain verbose select count(*), sum(val), avg(val), sum(val)::float8/count(*), val2 from tab1 group by val2 having avg(val) > 3.75 or val2 > 2;
                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=1.02..1.08 rows=1 width=8)
   Output: count(*), sum(val), avg(val), ((sum(val))::double precision / (count(*))::double precision), val2
   Filter: ((avg(tab1.val) > 3.75) OR (tab1.val2 > 2))
   ->  Sort  (cost=1.02..1.03 rows=1 width=8)
         Output: val, val2
         Sort Key: tab1.val2
         ->  Result  (cost=0.00..1.01 rows=1 width=8)
               Output: val, val2
               ->  Materialize  (cost=0.00..1.01 rows=1 width=8)
                     Output: val, val2
                     ->  Data Node Scan (Node Count [2])  (cost=0.00..1.01 rows=1000 width=8)
                           Output: val, val2
(12 rows)

select count(*), sum(val), avg(val), sum(val)::float8/count(*), val2 from tab1 group by val2 having avg(val) > 3.75 and val2 > 2;
 count | sum | avg | ?column? | val2 
-------+-----+-----+----------+------
(0 rows)

explain verbose select count(*), sum(val), avg(val), sum(val)::float8/count(*), val2 from tab1 group by val2 having avg(val) > 3.75 and val2 > 2;
                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=1.03..1.08 rows=1 width=8)
   Output: count(*), sum(val), avg(val), ((sum(val))::double precision / (count(*))::double precision), val2
   Filter: (avg(tab1.val) > 3.75)
   ->  Sort  (cost=1.03..1.03 rows=1 width=8)
         Output: val, val2
         Sort Key: tab1.val2
         ->  Result  (cost=0.00..1.02 rows=1 width=8)
               Output: val, val2
               ->  Materialize  (cost=0.00..1.02 rows=1 width=8)
                     Output: val, val2
                     ->  Data Node Scan (Node Count [2])  (cost=0.00..1.01 rows=1000 width=8)
                           Output: val, val2
(12 rows)

-- joins and group by and having
select count(*), sum(tab1.val * tab2.val), avg(tab1.val*tab2.val), sum(tab1.val*tab2.val)::float8/count(*), tab1.val2, tab2.val2 from tab1 full outer join tab2 on tab1.val2 = tab2.val2 group by tab1.val2, tab2.val2 having tab1.val2 + tab2.val2 > 2;
 count | sum |         avg         | ?column? | val2 | val2 
-------+-----+---------------------+----------+------+------
     6 |  96 | 16.0000000000000000 |       16 |    2 |    2
(1 row)

explain verbose select count(*), sum(tab1.val * tab2.val), avg(tab1.val*tab2.val), sum(tab1.val*tab2.val)::float8/count(*), tab1.val2, tab2.val2 from tab1 full outer join tab2 on tab1.val2 = tab2.val2 group by tab1.val2, tab2.val2 having tab1.val2 + tab2.val2 > 2;
                                                                                    QUERY PLAN                                                                                     
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=2.06..2.12 rows=1 width=16)
   Output: count(*), sum((tab1.val * tab2.val)), avg((tab1.val * tab2.val)), ((sum((tab1.val * tab2.val)))::double precision / (count(*))::double precision), tab1.val2, tab2.val2
   ->  Sort  (cost=2.06..2.06 rows=1 width=16)
         Output: tab1.val, tab2.val, tab1.val2, tab2.val2
         Sort Key: tab1.val2, tab2.val2
         ->  Nested Loop  (cost=0.00..2.05 rows=1 width=16)
               Output: tab1.val, tab2.val, tab1.val2, tab2.val2
               Join Filter: ((tab1.val2 = tab2.val2) AND ((tab1.val2 + tab2.val2) > 2))
               ->  Materialize  (cost=0.00..1.01 rows=1 width=8)
                     Output: tab1.val, tab1.val2
                     ->  Data Node Scan (Node Count [2]) on tab1  (cost=0.00..1.01 rows=1000 width=8)
                           Output: tab1.val, tab1.val2
               ->  Materialize  (cost=0.00..1.01 rows=1 width=8)
                     Output: tab2.val, tab2.val2
                     ->  Data Node Scan (Node Count [2]) on tab2  (cost=0.00..1.01 rows=1000 width=8)
                           Output: tab2.val, tab2.val2
(16 rows)

-- group by and having, without aggregate in the target list
select val2 from tab1 group by val2 having sum(val) > 8;
 val2 
------
    3
(1 row)

explain verbose select val2 from tab1 group by val2 having sum(val) > 8;
                                          QUERY PLAN                                          
----------------------------------------------------------------------------------------------
 GroupAggregate  (cost=1.02..1.05 rows=1 width=8)
   Output: val2
   Filter: (sum(tab1.val) > 8)
   ->  Sort  (cost=1.02..1.03 rows=1 width=8)
         Output: val2, val
         Sort Key: tab1.val2
         ->  Result  (cost=0.00..1.01 rows=1 width=8)
               Output: val2, val
               ->  Materialize  (cost=0.00..1.01 rows=1 width=8)
                     Output: val, val2
                     ->  Data Node Scan (Node Count [2])  (cost=0.00..1.01 rows=1000 width=8)
                           Output: val, val2
(12 rows)

select val + val2 from tab1 group by val + val2 having sum(val) > 5;
 ?column? 
----------
        4
        8
        9
(3 rows)

explain verbose select val + val2 from tab1 group by val + val2 having sum(val) > 5;
                                          QUERY PLAN                                          
----------------------------------------------------------------------------------------------
 GroupAggregate  (cost=1.03..1.05 rows=1 width=8)
   Output: ((val + val2))
   Filter: (sum(tab1.val) > 5)
   ->  Sort  (cost=1.03..1.03 rows=1 width=8)
         Output: val, val2, ((val + val2))
         Sort Key: ((tab1.val + tab1.val2))
         ->  Result  (cost=0.00..1.02 rows=1 width=8)
               Output: val, val2, (val + val2)
               ->  Materialize  (cost=0.00..1.01 rows=1 width=8)
                     Output: val, val2
                     ->  Data Node Scan (Node Count [2])  (cost=0.00..1.01 rows=1000 width=8)
                           Output: val, val2
(12 rows)

-- group by with aggregates in expression
select count(*) + sum(val) + avg(val), val2 from tab1 group by val2 having min(val) < val2;
      ?column?       | val2 
---------------------+------
 17.6666666666666667 |    3
(1 row)

explain verbose select count(*) + sum(val) + avg(val), val2 from tab1 group by val2 having min(val) < val2;
                                          QUERY PLAN                                          
----------------------------------------------------------------------------------------------
 GroupAggregate  (cost=1.02..1.07 rows=1 width=8)
   Output: (((count(*) + sum(val)))::numeric + avg(val)), val2
   Filter: (min(tab1.val) < tab1.val2)
   ->  Sort  (cost=1.02..1.03 rows=1 width=8)
         Output: val, val2
         Sort Key: tab1.val2
         ->  Result  (cost=0.00..1.01 rows=1 width=8)
               Output: val, val2
               ->  Materialize  (cost=0.00..1.01 rows=1 width=8)
                     Output: val, val2
                     ->  Data Node Scan (Node Count [2])  (cost=0.00..1.01 rows=1000 width=8)
                           Output: val, val2
(12 rows)

drop table tab1;
drop table tab2;
-- Combination 4 enable_hashagg off and replicated tables.
-- repeat the same tests for replicated tables
-- create required tables and fill them with data
create table tab1 (val int, val2 int) distribute by replication;
create table tab2 (val int, val2 int) distribute by replication;
insert into tab1 values (1, 1), (2, 1), (3, 1), (2, 2), (6, 2), (4, 3), (1, 3), (6, 3);
insert into tab2 values (1, 1), (4, 1), (8, 1), (2, 4), (9, 4), (3, 4), (4, 2), (5, 2), (3, 2);
-- having clause not containing any aggregate
select count(*), sum(val), avg(val), sum(val)::float8/count(*), val2 from tab1 group by val2 having val2 + 1 > 3;
 count | sum |        avg         |     ?column?     | val2 
-------+-----+--------------------+------------------+------
     3 |  11 | 3.6666666666666667 | 3.66666666666667 |    3
(1 row)

explain verbose select count(*), sum(val), avg(val), sum(val)::float8/count(*), val2 from tab1 group by val2 having val2 + 1 > 3;
                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=1.03..1.08 rows=1 width=8)
   Output: count(*), sum(val), avg(val), ((sum(val))::double precision / (count(*))::double precision), val2
   ->  Sort  (cost=1.03..1.03 rows=1 width=8)
         Output: val, val2
         Sort Key: tab1.val2
         ->  Result  (cost=0.00..1.02 rows=1 width=8)
               Output: val, val2
               ->  Materialize  (cost=0.00..1.02 rows=1 width=8)
                     Output: val, val2
                     ->  Data Node Scan (Node Count [1])  (cost=0.00..1.01 rows=1000 width=8)
                           Output: val, val2
(11 rows)

-- having clause containing aggregate
select count(*), sum(val), avg(val), sum(val)::float8/count(*), val2 from tab1 group by val2 having avg(val) > 3.75;
 count | sum |        avg         | ?column? | val2 
-------+-----+--------------------+----------+------
     2 |   8 | 4.0000000000000000 |        4 |    2
(1 row)

explain verbose select count(*), sum(val), avg(val), sum(val)::float8/count(*), val2 from tab1 group by val2 having avg(val) > 3.75;
                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=1.02..1.08 rows=1 width=8)
   Output: count(*), sum(val), avg(val), ((sum(val))::double precision / (count(*))::double precision), val2
   Filter: (avg(tab1.val) > 3.75)
   ->  Sort  (cost=1.02..1.03 rows=1 width=8)
         Output: val, val2
         Sort Key: tab1.val2
         ->  Result  (cost=0.00..1.01 rows=1 width=8)
               Output: val, val2
               ->  Materialize  (cost=0.00..1.01 rows=1 width=8)
                     Output: val, val2
                     ->  Data Node Scan (Node Count [1])  (cost=0.00..1.01 rows=1000 width=8)
                           Output: val, val2
(12 rows)

select count(*), sum(val), avg(val), sum(val)::float8/count(*), val2 from tab1 group by val2 having avg(val) > 3.75 or val2 > 2;
 count | sum |        avg         |     ?column?     | val2 
-------+-----+--------------------+------------------+------
     2 |   8 | 4.0000000000000000 |                4 |    2
     3 |  11 | 3.6666666666666667 | 3.66666666666667 |    3
(2 rows)

explain verbose select count(*), sum(val), avg(val), sum(val)::float8/count(*), val2 from tab1 group by val2 having avg(val) > 3.75 or val2 > 2;
                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=1.02..1.08 rows=1 width=8)
   Output: count(*), sum(val), avg(val), ((sum(val))::double precision / (count(*))::double precision), val2
   Filter: ((avg(tab1.val) > 3.75) OR (tab1.val2 > 2))
   ->  Sort  (cost=1.02..1.03 rows=1 width=8)
         Output: val, val2
         Sort Key: tab1.val2
         ->  Result  (cost=0.00..1.01 rows=1 width=8)
               Output: val, val2
               ->  Materialize  (cost=0.00..1.01 rows=1 width=8)
                     Output: val, val2
                     ->  Data Node Scan (Node Count [1])  (cost=0.00..1.01 rows=1000 width=8)
                           Output: val, val2
(12 rows)

select count(*), sum(val), avg(val), sum(val)::float8/count(*), val2 from tab1 group by val2 having avg(val) > 3.75 and val2 > 2;
 count | sum | avg | ?column? | val2 
-------+-----+-----+----------+------
(0 rows)

explain verbose select count(*), sum(val), avg(val), sum(val)::float8/count(*), val2 from tab1 group by val2 having avg(val) > 3.75 and val2 > 2;
                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=1.03..1.08 rows=1 width=8)
   Output: count(*), sum(val), avg(val), ((sum(val))::double precision / (count(*))::double precision), val2
   Filter: (avg(tab1.val) > 3.75)
   ->  Sort  (cost=1.03..1.03 rows=1 width=8)
         Output: val, val2
         Sort Key: tab1.val2
         ->  Result  (cost=0.00..1.02 rows=1 width=8)
               Output: val, val2
               ->  Materialize  (cost=0.00..1.02 rows=1 width=8)
                     Output: val, val2
                     ->  Data Node Scan (Node Count [1])  (cost=0.00..1.01 rows=1000 width=8)
                           Output: val, val2
(12 rows)

-- joins and group by and having
select count(*), sum(tab1.val * tab2.val), avg(tab1.val*tab2.val), sum(tab1.val*tab2.val)::float8/count(*), tab1.val2, tab2.val2 from tab1 full outer join tab2 on tab1.val2 = tab2.val2 group by tab1.val2, tab2.val2 having tab1.val2 + tab2.val2 > 2;
 count | sum |         avg         | ?column? | val2 | val2 
-------+-----+---------------------+----------+------+------
     6 |  96 | 16.0000000000000000 |       16 |    2 |    2
(1 row)

explain verbose select count(*), sum(tab1.val * tab2.val), avg(tab1.val*tab2.val), sum(tab1.val*tab2.val)::float8/count(*), tab1.val2, tab2.val2 from tab1 full outer join tab2 on tab1.val2 = tab2.val2 group by tab1.val2, tab2.val2 having tab1.val2 + tab2.val2 > 2;
                                                                                    QUERY PLAN                                                                                     
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=2.06..2.12 rows=1 width=16)
   Output: count(*), sum((tab1.val * tab2.val)), avg((tab1.val * tab2.val)), ((sum((tab1.val * tab2.val)))::double precision / (count(*))::double precision), tab1.val2, tab2.val2
   ->  Sort  (cost=2.06..2.06 rows=1 width=16)
         Output: tab1.val, tab2.val, tab1.val2, tab2.val2
         Sort Key: tab1.val2, tab2.val2
         ->  Nested Loop  (cost=0.00..2.05 rows=1 width=16)
               Output: tab1.val, tab2.val, tab1.val2, tab2.val2
               Join Filter: ((tab1.val2 = tab2.val2) AND ((tab1.val2 + tab2.val2) > 2))
               ->  Materialize  (cost=0.00..1.01 rows=1 width=8)
                     Output: tab1.val, tab1.val2
                     ->  Data Node Scan (Node Count [1]) on tab1  (cost=0.00..1.01 rows=1000 width=8)
                           Output: tab1.val, tab1.val2
               ->  Materialize  (cost=0.00..1.01 rows=1 width=8)
                     Output: tab2.val, tab2.val2
                     ->  Data Node Scan (Node Count [1]) on tab2  (cost=0.00..1.01 rows=1000 width=8)
                           Output: tab2.val, tab2.val2
(16 rows)

-- group by and having, without aggregate in the target list
select val2 from tab1 group by val2 having sum(val) > 8;
 val2 
------
    3
(1 row)

explain verbose select val2 from tab1 group by val2 having sum(val) > 8;
                                          QUERY PLAN                                          
----------------------------------------------------------------------------------------------
 GroupAggregate  (cost=1.02..1.05 rows=1 width=8)
   Output: val2
   Filter: (sum(tab1.val) > 8)
   ->  Sort  (cost=1.02..1.03 rows=1 width=8)
         Output: val2, val
         Sort Key: tab1.val2
         ->  Result  (cost=0.00..1.01 rows=1 width=8)
               Output: val2, val
               ->  Materialize  (cost=0.00..1.01 rows=1 width=8)
                     Output: val, val2
                     ->  Data Node Scan (Node Count [1])  (cost=0.00..1.01 rows=1000 width=8)
                           Output: val, val2
(12 rows)

select val + val2 from tab1 group by val + val2 having sum(val) > 5;
 ?column? 
----------
        4
        8
        9
(3 rows)

explain verbose select val + val2 from tab1 group by val + val2 having sum(val) > 5;
                                          QUERY PLAN                                          
----------------------------------------------------------------------------------------------
 GroupAggregate  (cost=1.03..1.05 rows=1 width=8)
   Output: ((val + val2))
   Filter: (sum(tab1.val) > 5)
   ->  Sort  (cost=1.03..1.03 rows=1 width=8)
         Output: val, val2, ((val + val2))
         Sort Key: ((tab1.val + tab1.val2))
         ->  Result  (cost=0.00..1.02 rows=1 width=8)
               Output: val, val2, (val + val2)
               ->  Materialize  (cost=0.00..1.01 rows=1 width=8)
                     Output: val, val2
                     ->  Data Node Scan (Node Count [1])  (cost=0.00..1.01 rows=1000 width=8)
                           Output: val, val2
(12 rows)

-- group by with aggregates in expression
select count(*) + sum(val) + avg(val), val2 from tab1 group by val2 having min(val) < val2;
      ?column?       | val2 
---------------------+------
 17.6666666666666667 |    3
(1 row)

explain verbose select count(*) + sum(val) + avg(val), val2 from tab1 group by val2 having min(val) < val2;
                                          QUERY PLAN                                          
----------------------------------------------------------------------------------------------
 GroupAggregate  (cost=1.02..1.07 rows=1 width=8)
   Output: (((count(*) + sum(val)))::numeric + avg(val)), val2
   Filter: (min(tab1.val) < tab1.val2)
   ->  Sort  (cost=1.02..1.03 rows=1 width=8)
         Output: val, val2
         Sort Key: tab1.val2
         ->  Result  (cost=0.00..1.01 rows=1 width=8)
               Output: val, val2
               ->  Materialize  (cost=0.00..1.01 rows=1 width=8)
                     Output: val, val2
                     ->  Data Node Scan (Node Count [1])  (cost=0.00..1.01 rows=1000 width=8)
                           Output: val, val2
(12 rows)

drop table tab1;
drop table tab2;
reset enable_hashagg;
